---
title: "Trabalho R"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
rm(list = ls())
install.packages('pacman')
install.packages('gridExtra')
install.packages('caret')
install.packages('corrplot')
install.packages('leaflet')
install.packages('tidyverse')
install.packages('tigris')
install.packages('ggthemes')
install.packages('ggmap')
install.packages('plotly')
install.packages('maps')
install.packages('readr')
```

```{r}
library("readr")
library("maps")
library("ggthemes")
library("readr") 
library("geosphere")
library("lubridate")
library("readr")
library("dplyr")
library("ggplot2")
library("gridExtra")
library("caret")
library("corrplot")
library("leaflet")
library("stringr")
library("dplyr")
library("leaflet")
library("tigris")
require("gridExtra")
library("ggmap")
library("tidyverse")
library("plotly")

```

```{r}

train1 <- read_csv(file.path("data", "train.csv"))
train <- rbind(train1)

```


Foi importada a base de treino com informações sobre as corridas, como mostra visualização abaixo

```{r train}
View(train)
```

## Including Plots
#######################
Vamos calcular a distância de todas corridas utilizando o pacote geosphere
Metodo Haversine que considera a esfera da terra

```{r , echo=FALSE}

train$distanceHaversine <- (distHaversine(cbind(train$pickup_longitude, train$pickup_latitude), cbind(train$dropoff_longitude, train$dropoff_latitude)))/1000

```
#######################
Agora vamos efetuar o calculo da distancia euclidiana

Diferença entre distancia Euclidiana e de Manhattan
Vamos imaginar uma a rota de GPS para dois veículos, uma para um carro e outra para um helicóptero. A Distância Euclidiana seria o segmento de uma reta na qual indicaria uma possível rota de helicóptero (na qual não haveria preocupação com as ruas já que é um veículo aéreo, e geometricamente seria a hipotenusa de um triângulo) e a Distância Manhattan seria um segmento de retas na vertical quanto na horizontal semelhante a uma rota de carro (já que esse obedece o sentido das ruas, e devido a esse comportamento essa medida de distãncia é também conhecida como City Block, e  geometricamente seriam a soma dos catetos).

```{r , echo=FALSE}

train$distanceEuclidean <- distGeo(cbind(train$pickup_longitude, train$pickup_latitude), cbind(train$dropoff_longitude, train$dropoff_latitude))/1000 





##Function to calculate distance in meters based on latitude and longitude
distancia <- function (la1,lo1,la2,lo2) {
  r = 6371.0;
  
  la1 = la1 * 3.141593 / 180.0;
  lo1 = lo1 * 3.141593 / 180.0;
  la2 = la2 * 3.141593 / 180.0;
  lo2 = lo2 * 3.141593 / 180.0;
  
  dif_latitude = la2 - la1;
  dif_longitude = lo2 - lo1;			 
  
  ##a = sin(dif_latitude / 2) * sin(dif_latitude / 2) + cos(la1) * cos(la2) * sin(dif_longitude / 2) * sin(dif_longitude / 2);    
 ## aa=sqrt(a);
  ###ab=sqrt(1 - a);	
  ##c = atan2(aa, ab) * 2;
  
  c = as.matrix((dif_latitude^2 + dif_longitude^2)^0.5)
  
  return (metros = round(r * c * 1000)/1000);
  
}


train  %>%
  select (pickup_latitude, pickup_longitude, dropoff_latitude, dropoff_longitude) -> my_trip

my_trip <- mutate (my_trip, 
                   distancia = distancia(pickup_latitude,pickup_longitude,dropoff_latitude,dropoff_longitude))
```
#######################
Abaixo descrevemos quais são os principais horários das corridas por dia da semana
```{r , echo=FALSE}
train$day_of_week <- wday(c(train$pickup_datetime), label = TRUE)
train$pickup_hour <- hour(c(train$pickup_datetime))
 
train_grouped_by_day <-  train %>%
    group_by(day_of_week, pickup_hour) %>%
    summarise(total = n()) 

ggplot(train_grouped_by_day, aes(x = factor(pickup_hour), y = total,fill=day_of_week)) +
        geom_bar(stat='identity')

```
#######################
Por dia do ano
```{r , echo=FALSE} 
 
train$day_of_year <- yday(c(train$pickup_datetime) ) 
 
train_grouped_by_day_of_year <-  train %>%
    group_by(day_of_year, pickup_hour) %>%
    summarise(total = n()) 

ggplot(train_grouped_by_day_of_year, aes(x = day_of_year, y = total,fill=pickup_hour)) +
        geom_bar(stat='identity')

```
#######################
Por hora do dia
```{r , echo=FALSE}  
ggplot(train_grouped_by_day, aes(x = factor(pickup_hour), y = total)) + 
        geom_bar(stat='identity')  

```

```{r , echo=FALSE}  
 
 View(c(train$pickup_longitude,train$pickup_latitude))

```
#######################
Principais origens em funÃ§Ã£o do horÃ¡rio
```{r , echo=FALSE}  
  
train$pickup_hour <- hour(train$pickup_datetime)
train$pickup_week <- week(train$pickup_datetime)
train$pickup_month <- month(train$pickup_datetime)
train$pickup_weekdays <- weekdays(train$pickup_datetime)
train$pickup_weekend <- ifelse(train$pickup_weekdays==1 | train$pickup_weekdays==7,"Weekend","not-Weekend")

train$dropoff_hour <- hour(train$dropoff_datetime)
train$dropoff_week <- week(train$dropoff_datetime)
train$dropoff_month <- month(train$dropoff_datetime)
train$dropoff_weekdays <- weekdays(train$dropoff_datetime)
train$dropoff_weekend <- ifelse(train$dropoff_weekdays==1 | train$dropoff_weekdays==7,"Weekend","not-Weekend")


train_pickup_latt_long_by_hour <-  train %>%
    group_by(pickup_longitude, pickup_latitude, pickup_hour) %>%
    summarise(total = n()) 
train_filtered_pickup_latt_long_by_hour <- filter(train_pickup_latt_long_by_hour, total > 2)
 
train_dropoff_latt_long_by_hour <-  train %>%
    group_by(dropoff_longitude, dropoff_latitude, dropoff_hour) %>%
    summarise(total = n()) 
train_filtered_dropoff_latt_long_by_hour <- filter(train_dropoff_latt_long_by_hour, total > 2)
 
pickup_max_long <- max(train$pickup_longitude)
pickup_max_lat <- max(train$pickup_latitude)
pickup_min_long <- min(train$pickup_longitude)
pickup_min_lat <- min(train$pickup_latitude)
 
ny_map <- qmap("new york, ny", 
                                zoom    = 13,  
                                exten   = "normal", 
                                maptype = "toner-lite", 
                                source  = "stamen")
 
grafico_origem <- ny_map +  
                 geom_point(aes(x      = pickup_longitude, 
                                y      = pickup_latitude,color=pickup_hour), 
                                data   = train_filtered_pickup_latt_long_by_hour,  #1 million data
                                size=2,alpha=1) +scale_colour_gradient(high="red",low='green')+ theme_gdocs()

grafico_origem 
```
#######################
Principais destinos em funÃ§Ã£o do horÃ¡rio
```{r , echo=FALSE}  
 grafico_destino <- ny_map +  
                 geom_point(aes(x      = dropoff_longitude, 
                                y      = dropoff_latitude,color=dropoff_hour), 
                                data   = train_filtered_dropoff_latt_long_by_hour,  #1 million data
                                size=2,alpha=1) +scale_colour_gradient(high="red",low='green')+ theme_gdocs()
 grafico_destino 
  
``` 
##########################
O tempo mÃ©dio da viagem em funÃ§Ã£o do horÃ¡rio
```{r , echo=FALSE}   
elapsed.time <- train$pickup_datetime %--% train$dropoff_datetime
train$tempo_corrida <- as.duration(elapsed.time) / dminutes(1)

tempo_medio_por_hour <-  train %>%
    group_by(pickup_hour) %>%
    summarise( media = mean(tempo_corrida)) 

ggplot(tempo_medio_por_hour, aes(x =  pickup_hour, y = media)) +
        geom_bar(stat='identity') 
```
##########################
Filtrar o dataset para anÃ¡lise sobre um conjunto menor de dados, que contenha pelo menos 5000 observaÃ§Ãµes

```{r , echo=FALSE} 
train_5000 <-  sample(train, size = 5000, replace = TRUE)
View(train_5000)
```
###########################
Criação do mapa de calor que toma como referência os de Fora da Ilha de Manhattan como referência.
```{r}
#rm(dataset.manhattan)

train$wday_pickup <- wday(train$pickup_datetime, label = TRUE)
train$wday_dropoff <- wday(train$dropoff_datetime, label = TRUE)

train$state_pickup <- map.where("state", train$pickup_longitude, train$pickup_latitude)
train$state_dropoff <- map.where("state", train$dropoff_longitude, train$dropoff_latitude)

dataset.fora_ilha_manhattan <- train[train$state_pickup != "new york:manhattan" & !is.na(train$state_pickup) & !is.na(train$state_dropoff),]

pickup_max_long_m <- max(dataset.fora_ilha_manhattan$pickup_longitude)
pickup_max_lat_m<- max(dataset.fora_ilha_manhattan$pickup_latitude)
pickup_min_long_m <- min(dataset.fora_ilha_manhattan$pickup_longitude)
pickup_min_lat_m<- min(dataset.fora_ilha_manhattan$pickup_latitude)

cfg <- list( x.min = pickup_min_lat_m, x.max = pickup_max_lat_m, x.step = 0.2,
             y.min = pickup_min_long_m, y.max =  pickup_max_long_m, y.step = 0.2)

#Sequencias e quantidades de X e Y
cfg$x.lim <- seq( from = cfg$x.min, to = cfg$x.max, by = cfg$x.step)
cfg$x.tamanho = (cfg$x.max - cfg$x.min) / cfg$x.step
cfg$y.lim <- seq( from = cfg$y.min, to = cfg$y.max, by = cfg$y.step)
cfg$y.tamanho = (cfg$y.max - cfg$y.min) / cfg$y.step
cfg$x.qtde <- length(cfg$x.lim) -1
cfg$y.qtde <- length(cfg$y.lim) -1
cfg$all.qtde <- cfg$x.qtde * cfg$y.qtde
cfg$x <- paste0('X', seq_len(cfg$x.qtde ) )
cfg$y <- paste0('Y', seq_len(cfg$y.qtde ) )

#Sequencias de todos os quadrantes
cfg$all <- paste0('q', seq_len(cfg$all.qtde ) )
names(cfg$all) <- cfg$all
```
#######################
Alteramos os parametros na composção da matriz que cria o mapa colocando os valores dinamicos que foran definidos na lógica do notebook anterior.
```{r}
mapa = matrix( data=cfg$all, nrow = cfg$y.qtde)
colnames(mapa) <- cfg$x
row.names(mapa) <- cfg$y
mapa[cfg$y.qtde:1, 1:cfg$x.qtde]
```
######################
Colocamos os atributos do mapa de forma dinamica seguindo o formato da matriz que foi gerada.
```{r}
mapa.att <- data.frame(names=cfg$all, row.names = cfg$all)
mapa.att <- mutate( mapa.att,
                    x = rep(cfg$x, each=cfg$y.tamanho),
                    y = rep(cfg$y, cfg$x.tamanho),
                    x.from = rep( cfg$x.lim[1:cfg$x.qtde], each=cfg$y.tamanho),
                    x.to = rep( cfg$x.lim[2:(cfg$x.qtde + 1)], each=cfg$y.tamanho),
                    y.from = rep( cfg$x.lim[1:cfg$y.qtde], cfg$x.tamanho),
                    y.to = rep( cfg$x.lim[2:(cfg$y.qtde + 1)], cfg$x.tamanho),
                    x.center = (x.to - x.from) / 2.0 + x.from,
                    y.center = (y.to - y.from) / 2.0 + y.from )

head(mapa.att, 31)
```
###################
Geração do Mapa com base nos pontos que foram passados como coordenadas de referência.
```{r}
cores.mapa  = c("white", "#63be7b", "#ffeb84",  "#f8696b")  
gradiente.mapa = colorRampPalette(cores.mapa)(n = 30)
 plot_ly(x = cfg$x,
         y = cfg$y,
         z = matrix(runif(cfg$x.qtde*cfg$y.qtde), ncol=cfg$x.qtde, nrow = cfg$y.qtde),
         colors = gradiente.mapa,
         type = "heatmap")
```
###################
Montando Subsets que seram utilizados para configuração dos gráficos.
```{r}
train$wday_pickup <- wday(train$pickup_datetime, label = TRUE)
train$wday_dropoff <- wday(train$dropoff_datetime, label = TRUE)

train$state_pickup <- map.where("state", train$pickup_longitude, train$pickup_latitude)
train$state_dropoff <- map.where("state", train$dropoff_longitude, train$dropoff_latitude)

dataset.fora_ilha <- train[train$state_pickup != "new york:manhattan" & !is.na(train$state_pickup) & !is.na(train$state_dropoff),]

dataset.manhattan <- train[train$state_pickup == "new york:manhattan" & train$state_dropoff == "new york:manhattan" & !is.na(train$state_pickup) & !is.na(train$state_dropoff),]


centralpark.embarques <- train[between(train$pickup_latitude, 40.764305, 40.800733) & between(train$pickup_longitude, -73.981766, -73.949234),]

centralpark.desembarques <- train[between(train$dropoff_latitude, 40.764305, 40.800733) & between(train$dropoff_longitude, -73.981766, -73.949234),]
```
#################
Mapa de Embarques considerando a região total do dataset.
```{r}
cfg_total <- list( x.min = -74.020042, x.max = -73.908892, x.step = 0.1,
             y.min = 40.700292, y.max = 40.878348, y.step = 0.1)

ggplot(data = dataset.fora_ilha_manhattan, aes(x=pickup_longitude, y=pickup_latitude)) +
  geom_point(size=0.06) +
  scale_x_continuous(limits=c(cfg_total$x.min, cfg_total$x.max)) +
  scale_y_continuous(limits=c(cfg_total$y.min, cfg_total$y.max)) + labs(title = "Mapa de embarques")
```
#################
Mapa de Desembarques considerando a região total do dataset.
```{r}

ggplot(data = dataset.manhattan, aes(x=dropoff_longitude, y=dropoff_latitude)) +
  geom_point(size=0.06) +
  scale_x_continuous(limits=c(cfg_total$x.min, cfg_total$x.max)) +
  scale_y_continuous(limits=c(cfg_total$y.min, cfg_total$y.max)) + labs(title = "Mapa de desembarques")
```
#################
Agregação
por state_pickup e por latitude/longitude (usando arredondamento)
```{r}
dataset.manhattan2 <- mutate(dataset.manhattan, pickup_lat = round(pickup_latitude, 4), pickup_long = round(pickup_longitude, 4), dropoff_lat = round(dropoff_latitude, 4), dropoff_long = round(dropoff_longitude, 4))

dataset.fora_ilha %>%
  filter(state_dropoff == "new york:manhattan" & (wday_pickup == 'sáb' | wday_pickup == 'dom' | wday_dropoff == 'sáb' | wday_dropoff == 'dom')) %>%
  group_by(state_pickup) %>%
  summarise(
    qtd_pickup = n(),
    mean_trip_duration = mean(trip_duration, na.rm = TRUE)
  ) %>% filter(qtd_pickup > 1) %>% head() 
```

```{r}
dataset.manhattan2 %>%
  group_by(pickup_lat, pickup_long) %>%
  summarise(
    qtd_pickups = n(),
    mean_trip_duration = mean(trip_duration, na.rm = TRUE)
  ) %>% filter(qtd_pickups > 1) %>% arrange(desc(qtd_pickups)) -> dataset.manhattan3

head(dataset.manhattan3)

```

```{r}
dataset.manhattan2 %>%
  group_by(dropoff_lat, dropoff_long) %>%
  summarise(
    qtd_dropoffs = n(),
    mean_trip_duration = mean(trip_duration, na.rm = TRUE)
  ) %>% filter(qtd_dropoffs > 1) %>% arrange(desc(qtd_dropoffs)) -> dataset.manhattan4

head(dataset.manhattan4)
```

```{r}
dataset.manhattan2 %>%
  filter(pickup_long == -73.9941 & pickup_lat == 40.7512) %>%
  group_by(dropoff_lat, dropoff_long) %>%
  summarise(
    pickup_long = -73.9941,
    pickup_lat = 40.7512,
    qtd_dropoffs = n(),
    mean_trip_duration = mean(trip_duration, na.rm = TRUE)
  ) %>% filter(qtd_dropoffs > 1) -> dataset.pennstation
#principais destinos de uma das saídas da Penn Station (447-441 8th Ave)
head(dataset.pennstation)
```
####################
Mapas
Mostrando locais próximos da Penn Station com muitos embarques (>190)
```{r}
dataset.manhattan3 %>% filter(qtd_pickups > 190) -> dataset.manhattan5

pennstation.map <- get_map(location= 'Pennsylvania Station, Nova York', 
                       maptype='roadmap', color='bw', source='google', zoom=16)
```

```{r}
ggmap(pennstation.map) + 
  geom_point(data=dataset.manhattan5,aes(x=pickup_long,y=pickup_lat,color=qtd_pickups),size=3,alpha=0.75)+
  scale_colour_gradient(high="red",low='green')
```

```{r}
manhattan.map <- get_map(location= 'Central Park, Manhattan, Nova York', 
                       maptype='roadmap', color='bw', source='google', zoom=13)
```

```{r}
ggmap(manhattan.map) + 
  geom_point(data=centralpark.embarques,aes(x=pickup_longitude,y=pickup_latitude),size=.03,alpha=0.3, color="green") + ggtitle("Mapa de embarques")
```

```{r}
ggmap(manhattan.map) +
  geom_point(data=centralpark.desembarques,aes(x=dropoff_longitude,y=dropoff_latitude),size=.03,alpha=0.3, color="red") + ggtitle("Mapa de desembarques")
```
############################################
Criação do Modelo K Means - Relacionando o tempo das viagens versus distancia percorrida (Utilizando distancia Euclidiana)
```{r}
set.seed(1) 
  
modelo = kmeans(train[,c('tempo_corrida','distanceEuclidean')], centers = 4)


plot(train[,c('distanceEuclidean','tempo_corrida')], col = modelo$cluster,
pch = 20, cex = 2)
points(modelo$centers, col = rev(seq_along(modelo$centers)), bg=seq_along(modelo$centers), pch = 24, cex =1, lwd = 1)
```



